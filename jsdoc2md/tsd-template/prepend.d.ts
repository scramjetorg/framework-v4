import {Readable, Writable, Transform} from "stream";

import {EventEmitter} from "events";

type AsyncGeneratorFunction<T=any> = (...args: any[]) => {[Symbol.asyncIterator]: {next(): Promise<{value: T, done: boolean}>}}
type AsyncFunction = (...args: any[]) => Promise<any>;
type ThenFunction = (arg: any) => any;
type Options = DataStreamOptions;

interface ArrayOptions {
    concurrency?: number;
    signal?: AbortSignal;
}

type SignalOption = Pick<ArrayOptions, "signal">;

declare class PromiseTransform implements Readable, Writable {
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    [Symbol.asyncDispose](): Promise<void>;
    iterator(options?: { destroyOnReturn?: boolean; }): AsyncIterableIterator<any>;
    map(fn: (data: any, options?: SignalOption) => any, options?: ArrayOptions): never;
    filter(fn: (data: any, options?: SignalOption) => boolean | Promise<boolean>, options?: ArrayOptions): never;
    forEach(fn: (data: any, options?: SignalOption) => void | Promise<void>, options?: ArrayOptions): never;
    toArray(options?: SignalOption): never;
    some(fn: (data: any, options?: SignalOption) => boolean | Promise<boolean>, options?: ArrayOptions): never;
    find<T>(fn: (data: any, options?: SignalOption) => data is T, options?: ArrayOptions): never;
    find(fn: (data: any, options?: SignalOption) => boolean | Promise<boolean>, options?: ArrayOptions): never;
    every(fn: (data: any, options?: SignalOption) => boolean | Promise<boolean>, options?: ArrayOptions): never;
    flatMap(fn: (data: any, options?: SignalOption) => any, options?: ArrayOptions): never;
    drop(limit: number, options?: SignalOption): Readable;
    take(limit: number, options?: SignalOption): Readable;
    asIndexedPairs(options?: SignalOption): Readable;
    reduce<T = any>(fn: (previous: any, data: any, options?: SignalOption) => T, initial?: undefined, options?: SignalOption): never;
    reduce<T = any>(fn: (previous: T, data: any, options?: SignalOption) => T, initial: T, options?: SignalOption): never;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    compose<T extends NodeJS.ReadableStream>(stream: T | ((source: any) => void) | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }): T;
    compose<T extends NodeJS.ReadableStream>(stream: T | ((source: any) => void) | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }): T;
    writableNeedDrain: boolean;
    closed: boolean;
    errored: Error;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    readableAborted: boolean;
    readableDidRead: boolean;
    _construct?(callback: (error?: Error) => void): void;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    writableEnded: boolean;
    writableFinished: boolean;
    writableHighWaterMark: number;
    writableLength: number;
    writableObjectMode: boolean;
    writableCorked: number;
    _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error) => void): void;
    _writev?(chunks: { chunk: any; encoding: BufferEncoding; }[], callback: (error?: Error) => void): void;
    _final(callback: (error?: Error) => void): void;
    setDefaultEncoding(encoding: BufferEncoding): this;
    cork(): void;
    uncork(): void;
    readableEncoding: BufferEncoding;
    readableEnded: boolean;
    readableFlowing: boolean;
    readableHighWaterMark: number;
    readableLength: number;
    readableObjectMode: boolean;
    destroyed: boolean;
    _read(size: number): void;
    push(chunk: any, encoding?: BufferEncoding): boolean;
    _destroy(error: Error, callback: (error?: Error) => void): void;
    destroy(error?: Error): this;
    readable: boolean;
    read(size?: number | undefined): string | Buffer;
    setEncoding(encoding: string): this;
    pause(): this;
    resume(): this;
    isPaused(): boolean;
    pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean | undefined; } | undefined): T;
    unpipe(destination?: NodeJS.WritableStream | undefined): this;
    unshift(chunk: string | Uint8Array, encoding?: "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex" | undefined): void;
    wrap(oldStream: NodeJS.ReadableStream): this;
    [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;
    addListener(event: string | symbol, listener: (...args: any[]) => void): this;
    on(event: string | symbol, listener: (...args: any[]) => void): this;
    once(event: string | symbol, listener: (...args: any[]) => void): this;
    removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
    off(event: string | symbol, listener: (...args: any[]) => void): this;
    removeAllListeners(event?: string | symbol | undefined): this;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners(event: string | symbol): Function[];
    rawListeners(event: string | symbol): Function[];
    emit(event: string | symbol, ...args: any[]): boolean;
    listenerCount(type: string | symbol): number;
    prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
    prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    eventNames(): (string | symbol)[];
    writable: boolean;
    write(buffer: string | Uint8Array, cb?: ((err?: Error | null | undefined) => void) | undefined): boolean;
    write(str: string, encoding?: string | undefined, cb?: ((err?: Error | null | undefined) => void) | undefined): boolean;
    end(cb?: () => void): this;
    end(data: string | Uint8Array, cb?: () => void): this;
    end(str: string, encoding?: string | undefined, cb?: () => void): this;
    addListener(event: string | symbol, listener: (...args: any[]) => void): this;
    on(event: string | symbol, listener: (...args: any[]) => void): this;
    once(event: string | symbol, listener: (...args: any[]) => void): this;
    removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
    off(event: string | symbol, listener: (...args: any[]) => void): this;
    removeAllListeners(event?: string | symbol | undefined): this;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners(event: string | symbol): Function[];
    rawListeners(event: string | symbol): Function[];
    emit(event: string | symbol, ...args: any[]): boolean;
    listenerCount(type: string | symbol): number;
    prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
    prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    eventNames(): (string | symbol)[];
}
